<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java字符串的压缩</title>
    <url>/2019/12/05/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>#题目</p>
<blockquote>
<p>编写程序，使其压缩字符串，例如：字符串:DDffhg;经过压缩得到:D2f2hg</p>
</blockquote>
<p>##代码</p>
<a id="more"></a> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  String str=s.nextLine();</span><br><span class="line">     StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     <span class="keyword">char</span> word1 = str.charAt(<span class="number">0</span>);<span class="comment">// 取第一个字符</span></span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">1</span>;<span class="comment">// 连续字符的个数</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">char</span> word2 = str.charAt(i);    <span class="comment">// 循环取字符</span></span><br><span class="line">         <span class="keyword">if</span> (word1 == word2) &#123;<span class="comment">// 把前一个字符和当前字符比较</span></span><br><span class="line">             sum++; <span class="comment">// 相同的字符 个数加1</span></span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">       	  result.append(word1); <span class="comment">// 拼接字符</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">       	  result.append(word1).append(sum); </span><br><span class="line">         word1 = word2;    <span class="comment">// 当前字符变为前一个字符</span></span><br><span class="line">         sum = <span class="number">1</span>;<span class="comment">// 重置</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"字符串压缩后:"</span> + result.append(word1).append(sum));<span class="comment">// 加上最后一个字符及个数，打印输出</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2019-12-5 21:44:31 星期四</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MAZE(C)</title>
    <url>/2019/11/16/MAZE-C/</url>
    <content><![CDATA[<p>#迷宫（C语言版）</p>
<blockquote>
<p>运用C语言栈，实现迷宫算法</p>
</blockquote>
<p>##思路</p>
<ol>
<li>从入口出发，我们首先规定：没经过一个点按照（东南西北）方向依次试探</li>
<li>若能通过，则将迷宫数组的值改为curstep++,</li>
<li>不能通过，则改变direction</li>
<li>如果东南西北四个方向都不能通过，回溯，并将迷宫数组的值改为-1</li>
<li>直到找到终点</li>
</ol>
<p>##具体实现</p>
<a id="more"></a>
<ol>
<li><p>首先创建迷宫数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;PostType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ord; <span class="comment">// 序号</span></span><br><span class="line">	PostType seat; <span class="comment">//坐标 </span></span><br><span class="line">	<span class="keyword">int</span> di;  <span class="comment">//方向</span></span><br><span class="line">&#125;SElemType;</span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">9</span>][<span class="number">9</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">PostType direct[<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 东南西北</span></span><br><span class="line"><span class="keyword">int</span> curstep = <span class="number">1</span>; <span class="comment">//记录步数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建栈，便于回溯（这里采用顺序栈）</p>
</li>
</ol>
<blockquote>
<p>顺序栈的基本操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	SElemType *base;</span><br><span class="line">	SElemType *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">( SqStack &amp;	S )</span></span>&#123; <span class="comment">//创建栈</span></span><br><span class="line">	S.base=(SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span><span class="comment">//入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize) &#123; </span><br><span class="line">		S.base=(SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType)); </span><br><span class="line">		<span class="keyword">if</span>(!S.base)   <span class="built_in">exit</span>(OVERFLOW); </span><br><span class="line">		S.top=S.base+S.stacksize; </span><br><span class="line">		S.stacksize+=STACKINCREMENT; </span><br><span class="line">	&#125;</span><br><span class="line">	*(S.top)++=e; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR ; <span class="comment">// Empty Stack</span></span><br><span class="line">	e= * (S.top<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迷宫求解</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pass</span> <span class="params">( PostType b)</span></span>&#123;  <span class="comment">//判断 能否 通过</span></span><br><span class="line">	<span class="keyword">if</span>(maze[b.x][b.y]==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FootPrint</span><span class="params">(PostType b)</span></span>&#123;  <span class="comment">// 标记 通过的 点</span></span><br><span class="line">	maze[b.x][b.y]=curstep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextPos</span><span class="params">(PostType &amp;b,<span class="keyword">int</span> di)</span></span>&#123; <span class="comment">// 偏移量</span></span><br><span class="line">	b.x=b.x+direct[di].x;</span><br><span class="line">	b.y=b.y+direct[di].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkPrint</span><span class="params">(PostType b)</span></span>&#123;  <span class="comment">// 不能通过</span></span><br><span class="line">	maze[b.x][b.y]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MazePath</span> <span class="params">(PostType begin,PostType end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PostType curpos;</span><br><span class="line">	SqStack s;</span><br><span class="line">	SElemType e;</span><br><span class="line">	curpos = begin;</span><br><span class="line">	InitStack (s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span>	&#123;</span><br><span class="line">		e.di=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(Pass ( curpos) )&#123;<span class="comment">//判断 位置能否通过</span></span><br><span class="line">			FootPrint( curpos );<span class="comment">//留下足迹</span></span><br><span class="line">			e.di=<span class="number">0</span>;<span class="comment">//每次都从东开始走</span></span><br><span class="line">			e.ord=curstep;<span class="comment">//栈元素的序号变为当前足迹curstep</span></span><br><span class="line">			e.seat=curpos;<span class="comment">//栈元素变为当前位置</span></span><br><span class="line">			curstep++;<span class="comment">//足迹加有1</span></span><br><span class="line">			Push( s , e);<span class="comment">//入栈</span></span><br><span class="line">			<span class="keyword">if</span>(curpos.x==end.x &amp;&amp; curpos.y==end.y)</span><br><span class="line">				<span class="keyword">return</span> TRUE;</span><br><span class="line">			NextPos( curpos , e.di);<span class="comment">//有当前位置和direct，确定下一个位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!StackEmpty(s))&#123;<span class="comment">//栈不空</span></span><br><span class="line">				Pop(s,e);<span class="comment">//出栈</span></span><br><span class="line">				curstep--;<span class="comment">//足迹减1</span></span><br><span class="line">				<span class="keyword">while</span>( e.di==<span class="number">3</span> &amp;&amp; !StackEmpty(s) )&#123;前一位置处于最后一个方向（北）且栈不空</span><br><span class="line">					MarkPrint( e.seat );<span class="comment">//标记为-1</span></span><br><span class="line">					Pop(s,e);<span class="comment">//出栈</span></span><br><span class="line">					curstep--;<span class="comment">//足迹减1</span></span><br><span class="line">				&#125;<span class="comment">//while </span></span><br><span class="line">				<span class="keyword">if</span>(e.di&lt;<span class="number">4</span>)&#123;<span class="comment">//未到最后一个方向</span></span><br><span class="line">					e.di++;<span class="comment">//换个方向</span></span><br><span class="line">					Push(s,e);<span class="comment">//入栈</span></span><br><span class="line">					curstep ++ ;<span class="comment">//足迹加1</span></span><br><span class="line">					curpos = e.seat;<span class="comment">//确定当前位置</span></span><br><span class="line">					NextPos(curpos,e.di);<span class="comment">//确定下一个位置</span></span><br><span class="line">				&#125;<span class="comment">//if</span></span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(!StackEmpty(s));</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##总结<br>从入口到出口的一条路径由全局maze数组显示。入口值依次为2，3，等。其中栈元素的di成员的值为0~3，数组maze的作用是当探测失败的时，通过退栈回到前一点，从前一点再继续试探。</p>
<blockquote>
<p>2019-11-14 13:29:31 星期四</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2019/09/10/hello-world/</url>
    <content><![CDATA[<h1 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h1><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><pre><code>这是一篇写于 2019-9-12 的一篇博客</code></pre><a id="more"></a>
<h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><pre><code>为什么要写博客，给自己找一些事情做</code></pre>]]></content>
  </entry>
</search>
