<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python学习</title>
    <url>/2020/01/17/python%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="开始Python的学习之路"><a href="#开始Python的学习之路" class="headerlink" title="开始Python的学习之路"></a>开始Python的学习之路</h1><blockquote>
<p><a href="https://github.com/jackfrued/Python-100-Days.git" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days.git</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>将个人博客同时部署到GitHub和coding</title>
    <url>/2020/01/12/%E5%B0%86%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E5%92%8Ccoding/</url>
    <content><![CDATA[<h1 id="将个人博客同时部署到GitHub和coding"><a href="#将个人博客同时部署到GitHub和coding" class="headerlink" title="将个人博客同时部署到GitHub和coding"></a>将个人博客同时部署到GitHub和coding</h1><blockquote>
<p>之前是将个人部署到GitHub上的，但访问速度很慢，于是选择了同时部署到GitHub和coding上，做国内外分流。<br>本文是在已将个人博客部署在GitHub的基础上，将个人博客部署到coding，实现分流访问</p>
</blockquote>
<a id="more"></a> 

<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>1.创建coding用户</p>
<p>2.创建一个新的项目<br>    <img src="https://s2.ax1x.com/2020/01/12/lopEhn.jpg" alt="lopEhn.jpg"></p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>将存放在GitHub的代码导入到刚刚新建的coding内<br>1.本地执行<br>    <figure class="highlight plain"><figcaption><span>clone</span><a href="https://github.com/antirez/redis.git(这里填你代码仓的地址)" target="_blank" rel="noopener">--bare ```</a></figcaption><table><tr><td class="code"><pre><span class="line">2.打开git bash ，输入 ls</span><br><span class="line">	[![lopY1x.md.jpg](https://s2.ax1x.com/2020/01/12/lopY1x.md.jpg)](https://imgchr.com/i/lopY1x)</span><br><span class="line">	找到与自己GitHub仓库名相同的那个文件（这里是 c-yuqi.github.io.git）</span><br><span class="line">3.将克隆下来的仓库推送到 CODING</span><br><span class="line">	使用仓库页面提供的 URL。</span><br><span class="line">	[![lorLh6.md.jpg](https://s2.ax1x.com/2020/01/12/lorLh6.md.jpg)](https://imgchr.com/i/lorLh6)</span><br></pre></td></tr></table></figure></p>
<pre><code>cd c-yuqi.github.io.git
git push https://git.coding.net/jiong/redis.git --all</code></pre><p>```</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>将ssh公匙填入coding<br><a href="https://imgchr.com/i/lo5Gn0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/12/lo5Gn0.md.jpg" alt="lo5Gn0.md.jpg"></a></p>
<blockquote>
<p>如果没有ssh公匙可以参考<a href="https://blog.csdn.net/weixin_39417086/article/details/86572434" target="_blank" rel="noopener">Git配置ssh公钥</a></p>
</blockquote>
<p> <a href="https://imgchr.com/i/looRld" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/12/looRld.md.jpg" alt="looRld.md.jpg"></a></p>
<p>​    然后 打开page服务</p>
<p>​    <img src="https://s2.ax1x.com/2020/01/12/loIub6.jpg" alt="loIub6.jpg"></p>
<h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><p>更改hexo的根目录配置文件_config.yml</p>
<p><a href="https://imgchr.com/i/loopzd" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/12/loopzd.md.jpg" alt="loopzd.md.jpg"></a></p>
<h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><p>开始分流，国内的结点访问coding，国外的结点访问GitHub</p>
<p>coding的主机记录值为 www ,记录类型为 CNAME ， 解析线路 默认 </p>
<p><a href="https://imgchr.com/i/loTAXR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/01/12/loTAXR.md.jpg" alt="loTAXR.md.jpg"></a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java字符串的压缩</title>
    <url>/2019/12/05/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>#题目</p>
<blockquote>
<p>编写程序，使其压缩字符串，例如：字符串:DDffhg;经过压缩得到:D2f2hg</p>
</blockquote>
<p>##代码</p>
<a id="more"></a> 
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  String str=s.nextLine();</span><br><span class="line">     StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">     <span class="keyword">char</span> word1 = str.charAt(<span class="number">0</span>);<span class="comment">// 取第一个字符</span></span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">1</span>;<span class="comment">// 连续字符的个数</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">char</span> word2 = str.charAt(i);    <span class="comment">// 循环取字符</span></span><br><span class="line">         <span class="keyword">if</span> (word1 == word2) &#123;<span class="comment">// 把前一个字符和当前字符比较</span></span><br><span class="line">             sum++; <span class="comment">// 相同的字符 个数加1</span></span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(sum==<span class="number">1</span>)</span><br><span class="line">       	  result.append(word1); <span class="comment">// 拼接字符</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">       	  result.append(word1).append(sum); </span><br><span class="line">         word1 = word2;    <span class="comment">// 当前字符变为前一个字符</span></span><br><span class="line">         sum = <span class="number">1</span>;<span class="comment">// 重置</span></span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"字符串压缩后:"</span> + result.append(word1).append(sum));<span class="comment">// 加上最后一个字符及个数，打印输出</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2019-12-5 21:44:31 星期四</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>MAZE(C)</title>
    <url>/2019/11/16/MAZE-C/</url>
    <content><![CDATA[<p>#迷宫（C语言版）</p>
<blockquote>
<p>运用C语言栈，实现迷宫算法</p>
</blockquote>
<p>##思路</p>
<ol>
<li>从入口出发，我们首先规定：没经过一个点按照（东南西北）方向依次试探</li>
<li>若能通过，则将迷宫数组的值改为curstep++,</li>
<li>不能通过，则改变direction</li>
<li>如果东南西北四个方向都不能通过，回溯，并将迷宫数组的值改为-1</li>
<li>直到找到终点</li>
</ol>
<p>##具体实现</p>
<a id="more"></a>
<ol>
<li><p>首先创建迷宫数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;PostType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ord; <span class="comment">// 序号</span></span><br><span class="line">	PostType seat; <span class="comment">//坐标 </span></span><br><span class="line">	<span class="keyword">int</span> di;  <span class="comment">//方向</span></span><br><span class="line">&#125;SElemType;</span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">9</span>][<span class="number">9</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">PostType direct[<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">// 东南西北</span></span><br><span class="line"><span class="keyword">int</span> curstep = <span class="number">1</span>; <span class="comment">//记录步数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建栈，便于回溯（这里采用顺序栈）</p>
</li>
</ol>
<blockquote>
<p>顺序栈的基本操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	SElemType *base;</span><br><span class="line">	SElemType *top;</span><br><span class="line">	<span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">( SqStack &amp;	S )</span></span>&#123; <span class="comment">//创建栈</span></span><br><span class="line">	S.base=(SElemType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</span><br><span class="line">	S.top=S.base;</span><br><span class="line">	S.stacksize=STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span><span class="comment">//入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base==S.stacksize) &#123; </span><br><span class="line">		S.base=(SElemType*)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType)); </span><br><span class="line">		<span class="keyword">if</span>(!S.base)   <span class="built_in">exit</span>(OVERFLOW); </span><br><span class="line">		S.top=S.base+S.stacksize; </span><br><span class="line">		S.stacksize+=STACKINCREMENT; </span><br><span class="line">	&#125;</span><br><span class="line">	*(S.top)++=e; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span> </span>&#123; <span class="comment">//出栈</span></span><br><span class="line">	<span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR ; <span class="comment">// Empty Stack</span></span><br><span class="line">	e= * (S.top<span class="number">-1</span>);</span><br><span class="line">	S.top=S.top<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>迷宫求解</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pass</span> <span class="params">( PostType b)</span></span>&#123;  <span class="comment">//判断 能否 通过</span></span><br><span class="line">	<span class="keyword">if</span>(maze[b.x][b.y]==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FootPrint</span><span class="params">(PostType b)</span></span>&#123;  <span class="comment">// 标记 通过的 点</span></span><br><span class="line">	maze[b.x][b.y]=curstep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextPos</span><span class="params">(PostType &amp;b,<span class="keyword">int</span> di)</span></span>&#123; <span class="comment">// 偏移量</span></span><br><span class="line">	b.x=b.x+direct[di].x;</span><br><span class="line">	b.y=b.y+direct[di].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MarkPrint</span><span class="params">(PostType b)</span></span>&#123;  <span class="comment">// 不能通过</span></span><br><span class="line">	maze[b.x][b.y]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">MazePath</span> <span class="params">(PostType begin,PostType end )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PostType curpos;</span><br><span class="line">	SqStack s;</span><br><span class="line">	SElemType e;</span><br><span class="line">	curpos = begin;</span><br><span class="line">	InitStack (s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span>	&#123;</span><br><span class="line">		e.di=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(Pass ( curpos) )&#123;<span class="comment">//判断 位置能否通过</span></span><br><span class="line">			FootPrint( curpos );<span class="comment">//留下足迹</span></span><br><span class="line">			e.di=<span class="number">0</span>;<span class="comment">//每次都从东开始走</span></span><br><span class="line">			e.ord=curstep;<span class="comment">//栈元素的序号变为当前足迹curstep</span></span><br><span class="line">			e.seat=curpos;<span class="comment">//栈元素变为当前位置</span></span><br><span class="line">			curstep++;<span class="comment">//足迹加有1</span></span><br><span class="line">			Push( s , e);<span class="comment">//入栈</span></span><br><span class="line">			<span class="keyword">if</span>(curpos.x==end.x &amp;&amp; curpos.y==end.y)</span><br><span class="line">				<span class="keyword">return</span> TRUE;</span><br><span class="line">			NextPos( curpos , e.di);<span class="comment">//有当前位置和direct，确定下一个位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!StackEmpty(s))&#123;<span class="comment">//栈不空</span></span><br><span class="line">				Pop(s,e);<span class="comment">//出栈</span></span><br><span class="line">				curstep--;<span class="comment">//足迹减1</span></span><br><span class="line">				<span class="keyword">while</span>( e.di==<span class="number">3</span> &amp;&amp; !StackEmpty(s) )&#123;前一位置处于最后一个方向（北）且栈不空</span><br><span class="line">					MarkPrint( e.seat );<span class="comment">//标记为-1</span></span><br><span class="line">					Pop(s,e);<span class="comment">//出栈</span></span><br><span class="line">					curstep--;<span class="comment">//足迹减1</span></span><br><span class="line">				&#125;<span class="comment">//while </span></span><br><span class="line">				<span class="keyword">if</span>(e.di&lt;<span class="number">3</span>)&#123;<span class="comment">//未到最后一个方向</span></span><br><span class="line">					e.di++;<span class="comment">//换个方向</span></span><br><span class="line">					Push(s,e);<span class="comment">//入栈</span></span><br><span class="line">					curstep ++ ;<span class="comment">//足迹加1</span></span><br><span class="line">					curpos = e.seat;<span class="comment">//确定当前位置</span></span><br><span class="line">					NextPos(curpos,e.di);<span class="comment">//确定下一个位置</span></span><br><span class="line">				&#125;<span class="comment">//if</span></span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(!StackEmpty(s));</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##总结<br>从入口到出口的一条路径由全局maze数组显示。入口值依次为2，3，等。其中栈元素的di成员的值为0~3，数组maze的作用是当探测失败的时，通过退栈回到前一点，从前一点再继续试探。</p>
<blockquote>
<p>2019-11-14 13:29:31 星期四</p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2019/09/10/hello-world/</url>
    <content><![CDATA[<h1 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h1><p>  2019-9-12 ​    </p>
]]></content>
  </entry>
</search>
